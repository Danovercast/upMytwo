## **说说线程池**
<pre>
线程池主要工作是控制线程运行的数量,任务处理过程中创建并启动对应任务,当任务数量超出队列限制数目时,任务将进行排队等候,当其他线程运行
完毕后等待的任务再会从队列中出来执行.线程池的特点:线程复用,控制线程并发,管理线程.
  Java中通过Executor框架实现线程池，Executor、Executors、ExecutorService、ThreadPoolExecutor这几个类、接口都属于Java
  JUC包下的。创建线程池的几个重要参数，
    1.corePoolSize:线程池中核心线程大小(没有任务时线程的数量)，创建线程池后默认是没有线程的，当有任务后线程池才会创建线程，当前一个任务
    还未执行完，又新加任务时就会增加线程数目，线程数目的上限就是corePoolSize，超过上限后任务就会被暂存在队列中等待。即corePoolSize是队
    列不满时线程池中最大并行运行线程的上限。
    2.maximumPoolSize:线程池允许最大线程数，表示最大能创建多少个线程，线程池中当前线程数目不能超过该数量，若队列已满，且当前线程
    个数小于maximumPoolSize，线程池会创建新的线程来执行任务，这里值得一提的是largestPoolSize，该变量记录线程池整个生命周期中
    出现的最大线程个数。
    3.PoolSize:线程池中当前线程数量。
  通过讲述一下三者的联系来理解一下彼此的关系：当一个任务新加入线程池时，  
        1.此时corePoolSize>PoolSize: 代表此时运行的线程未达到核心线程数目，创建线程并执行该任务
        2.此时corePoolSize=PoolSize: 代表此时运行线程等于核心线程，再加一个任务就超了，会加入到等待队列中直到等待队列满了
        3.此时corePoolsize=PoolSize，且等待队列满了: 若PoolSize &lt; maximumPoolSize 则会创建新线程处理任务
        4.此时maximumPoolSize=PoolSize: 代表队列满了，且线程运行个数到达了最大值，再新加任务的话会执行拒绝策略
      PS：从上述描述可以知道三者大小关系，corePoolSize&lt;=maximumPoolSize;poolSize&lt;=maximumPoolSize;poolSize与corePoolSize
      大小关系不能一概比较。  
  
      线程池的拒绝策略：拒绝策略均需实现RejectedExecutionHandler接口方法rejectedExecution
        1.AbortPolicy，空方法，代表丢弃任务，但是会抛出RejectedExecutionException异常
        2.CallerRunsPolicy，调用入参r.run();也就是当添加到线程池中失败时由主线程来运行
        3.DiscardPolicy，空方法，丢弃任务，不会抛异常
        4.DiscardOldestPolicy，从线程池中的等待队列中取出队首元素，丢弃
        5.自定义策略，实现接口RejectedExecutionHandler的方法void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
    4.keepAliveTime：空闲存活时间，线程池中的线程在多久内没有干活后停止，默认情况下这里被shutdown的线程是非corePollSize的线程，      
    5.Unit：时间单位，空闲时间的单位
    6.WorkQueue：等待队列，用于存储那些等待线程资源运行的任务，当前运行任务大于corePollSize，且队列没满的情况下，新加任务会进入队列中
    7.ThreadFactory：线程工厂，用于创建线程。
    8.Handler：线程池的拒绝策略
    
      线程池的队列：workQueue类型为BlockingQueue&lt;Runnable&gt;看名字就知道是阻塞队列了，通常可取以下三类：
        1.有界任务队列ArrayBlockingQueue，基于数组先进先出，数组嘛，创建时就要给定长度了当然是有界的了。
        2.无界任务队列LinkedBlockingQueue，基于链表先进先出，若创建时未指定链表大小，默认大小是Integer.MAX_VALUE长度的
        3.直接提交队列synchronousQueue，该队列不会保存任务，而是创建线程执行新来的任务。
          --TODO- 这个synchronousQueue有时间得搞明白来
               
  关闭线程池：ThreadPoolExecutor提供两个关闭方法，shutdown();shutdownNow();其中，shutdown方法不会立刻关闭线程池，它会等到
  缓存队列中所有任务执行完后再关闭线程池，且shutdown后便不再接受新的任务；shutdownNow会立刻终止线程池，并尝试打断正在执行的任务，
  清空等待队列返回尚未执行完的任务。shutdown方法是void的，shutdownNow方法返回值是List &lt;Runnable&gt;的        
  
  常用的线程池：
    1.newSingleThreadExecutor:创建单线程线程池，能保证加入线程池的任务顺序执行（因为该线程池提供的构造函数中无队列参数，内部实现
    给的阻塞队列是LinkedBlockingQueue）
    2.newFixedThreadPool:创建可重用固定大小的线程池，即便线程处于空闲，线程也不会被回收，除非线程池被关闭，当任务达到线程池初始化
    线程大小后，新加的任务便会进入等待队列，该队列是LinkedBlockingQueue的且是默认长度的（Integer.MAX_VALUE）
    3.newCachedThreadPool:可缓存线程池，线程数量不定，且最大线程是Integer.MAX_VALUE;如果线程池长度超过处理需要，可灵活回收线程，
    若无可回收线程，则创建新线程。线程池中的空闲线程有keepAliveTime，60s，此类线程池适合大量耗时小的任务。
    4.newScheduledThreadPool:创建定长线程池，支持定时、周期性的执行。适用于定时任务        
    
  一个任务从被提交到被执行，线程池做了哪些工作?
  
</pre>

## **关于锁**
<pre>
Java并发体系中的锁。七类：
1.偏向锁、轻量锁、重量锁
2.可重入锁、非可重入锁
3.共享锁、独占锁
4.公平锁、非公平锁
5.悲观锁、乐观锁
6.自旋锁、非自旋锁
7.可中断锁、不可中断锁
    1
    偏向锁：当锁不存在竞争时，该锁就没u存在的必要，只需打上个标记，这个步骤由jvm来执行。一个对象初始后还没有任何线程来获取它的锁的时候
  这个锁就可能是偏向的，当有第一个线程来获取的时候，它就将对应线程记录下来，以后如果来获取锁的是该记录线程就可以直接获取对应锁，开销更小。
    轻量锁：JVM开发者很多情况下，synchronized中代码是被多个线程交替执行的，而不是同时执行的，也就是说不存在竞争关系，或者竞争时间短，用
  CAS操作就能解决，没必要用synchronized重量锁，轻量锁是指当锁原来是偏向锁的时候，被另外线程访问了，说明存在竞争，那么偏向锁就会升级为
  轻量锁，线程通过自选操作等待获取锁资源，而非阻塞
    重量锁：互斥锁，利用操作系统的同步机制实现，开销较大，当多个线程存在实际竞争关系且竞争时间长时，轻量级锁满足不了要求，锁会膨胀为重量锁
  让其他申请但拿不到锁的线程阻塞。
    锁升级：无锁--偏向锁--轻量锁--重量锁
    2
    可重入锁：ReentrantLock，当前线程若已持有当前请求资源的锁时，能在不释放锁的情况下直接获取对应资源的锁；相反不可重入锁是即便当前对
    像以有请求资源的锁时也需要先释放对应锁才能再获取锁。
    3
    共享锁：一把锁可以被多个线程同时获得，独占锁：同一时刻只能有一个线程获得锁；按读写锁的方式来理解
    4
    公平锁：在等待锁资源的的情况下，公平锁会根据等待队列的顺序决定应该给哪个线程锁，非公平锁：先等待的线程不一定能优先获取锁
    5
    悲观锁：悲观锁认为数据一定存在竞争，所以要在获取资源之前拿到锁，进行独占；乐观锁不同，乐观锁认为数据不一定被改变，只有在改写数据的
    时候才会尝试锁住资源。乐观锁通过CAS的操作对数据进行更新修改。
    6
    不可中断锁：一旦申请获得锁成功，其他资源便只能等待拥有锁的线程释放锁，不能进行中断去做其他事情，也就是被阻塞；而可中断锁不同，在等待
    锁资源的时候，它允许停止获取锁进行中断获取锁的操作，转而进行其他操作。
   
</pre>

## **ReentrantLock使用场景**
<pre>
1.耗时操作重复点击提交。根据ReentrantLock.tryLock()状态决定是否继续操作。
2.阻塞执行，类似于synchronized，防止资源冲突，保证同一时刻只有一个线程可操作资源，适用于资源的竞争（读写文件、消息发送），可通过
lock.lock();阻塞程序运行
3.当锁被其他线程拿着的时候等待一段时间，等不到则不再获取锁，通过lock.tryLock(long,timeUnit);实现
4.运行一段程序，当发现该操作正在进行中则等待执行，期间可中断正在进行的操作立刻释放锁继续下一操作。这也是ReentrantLock与synchronized不
同的一个地方，是否可中断。lock.lockInterruptibly();

</pre>

````java
//耗时操作重复点击
//共享资源：
 class RR implements Runnable{
   private ReentrantLock lock=new ReentrantLock();
   public void run (){
     if(lock.tryLock()){
       //当前线程拿到了锁
       sout(Thread.current.getName());
       lock.unLock();
     }
   }
 }
// 资源请求类：
 class Test{
  psvm(){
    RR r=new RR();
    Thread t1=new Thread(r);
    Thread t2=new Thread(r);
    Thread t3=new Thread(r);
    t1.start();
    t2.start();
    t3.start();
  }
 }
 //输出结果：只要电脑CPU多核且运行速度足够，就只会打印一条，可在主线程start前进行sleep或者在RR类中tryLock加上超时时间

````

## **死锁条件**
<pre>
1.互斥；2.占有和保持；3.不可剥夺；4.循环等待
</pre>

## **AQS**
<pre>
AQS：AbstractQueuedSynchronizer，抽象队列同步器，实现了对同步状态的管理，及对阻塞线程进行排队，等待通知等。AQS的核心包括：同步队
列、独占锁的获取与释放，共享锁的获取与释放，可中断锁，超时锁等。AQS是个抽象类，只作为一个模板（但很多）
</pre>