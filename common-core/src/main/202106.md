## **微服务用的什么体系**
<pre>
</pre>

## **什么是熔断**
<pre>
  在互联网应用中当下游服务因访问压力过大导致响应变慢甚至无法访问，上游应用为保证系统整体可用性，可以暂时切断对下游应用服务端的调用。这种牺牲局部保全整体的措施
就叫熔断。假设我们有服务调用如下：A--&gt;B--&gt;C，一旦下游服务变得不可用，积压了大量请求，服务B请求线程便亦随着阻塞，线程资源逐渐耗尽，接着B服务也变得不可用
最后服务A也不可用了，整个服务调用链路就此拖垮。此类调用链路连锁故障叫雪崩，这种情况就需要熔断机制。
  在此之前，需要知道 1.熔断开启：在固定时间内，接口调用超时比例到达一个设定的阈值时便会开启熔断，进入熔断状态后，后续对该服务的调用便不再经过被熔断的网络，转而执
行本地默认方法，达到服务降级的效果。2.熔断回复：熔断不会是永久的，当经过规定时间后，服务将从熔断状态恢复，再次接受远程调用。
  
</pre>

## **Hystrix**
<pre>
  SpringCloud的hystrix便很好的实现了熔断机制，实现了服务熔断、线程隔离等一系列服务保护功能，对于熔断机制的实现，hystrix设计了三种状态：1.熔断关闭，服务未出现
故障时，熔断器不对服务调用方做任何限制；2.熔断开启，设定时间内(hystrix默认时10s)接口调用出错比例到达设置的阈值(hystrix默认是0.5)会开启熔断，此后对该服务的调用
将不会实际上经过网络，而是执行本地callback方法；3.半熔断状态，在进入熔断开启状态一段时间后(hystrix默认是5s)，熔断器进入半熔断状态，所谓半熔断是指尝试恢复调用，
允许有限的流量调用熔断的服务，并监控成功比例，当成功率达到预期时，便关闭熔断，弱成功率仍然很低，则重新进入熔断状态。
  说说hystrix
  hystrix的核心概念，
    1.资源隔离，hystrix提供两种资源隔离策略，线程池隔离、信号量隔离。1）线程池隔离：为每一个依赖创建一个线程池来处理来自该依赖的请求，不同依赖线
程池相互隔离，就算依赖A故障，导致线程池资源耗尽，也不会影响其它依赖的线程资源，优点：支持排队和超时，支持异步调用；缺点：线程的创建和调度会消耗性能。适用场景：
适合逻辑复杂、耗时较长的且与第三方中间件有交互的，因为线程池模式的请求线程与实际转发线程不是同一个，所以可以保证容器有足够的线程来处理新的请求。2）信号量隔离：
初始化信号量currentCount=0；每进一个请求需要将currentCount自增，再判断该值是否小于系统最大信号量，小于则继续，大于则返回失败；优点：轻量无额外开销，只是一个
简单的计数器；缺点：不支持任务排队和主动超时，不支持异步调用，适用场景：适合能快速响应的接口，不适合一些耗时较长的接口场景，因为信号量模式下的请求线程与转发处理
线程是同一个，如果接口耗时太长有可能导致容器线程占满。
    2.断路器，hystrix是基于滚筒来处理的，每一秒产生一个buckets，每产生一个新的buckets就移除一个最老的buckets，默认是10s一个buckets，buckets在内存中是一种
数据结构，每个buckets会记录metrics的相关记录，成功、失败、超时、拒绝，当一个HystrixCommand进来后，会先通过allowRequest()方法判断是否允许通过该次请求，该方法
通过判断是否成功或者isOpen()，判断断路器是否打开，断路器如关闭此请求则通过，断路器如打开，则会判断是否过了睡眠周期，没过睡眠周期返回false，拒绝通过该请求，过了
会尝试放行。isOpen()按照fail/total 计算比例，若失败率达到阈值则会触发熔断，其中计算数据来源于窗口期，即一个buckets中的数据。对于一个依赖调用，只有成功、失败、超时、
拒绝四种状态，这些调用结果都会记录到buckets中，对于调用成功，还会判断断路器是否打开，如果是打开的，则会关闭断路器并重置相关计数器。
    3.降级回退，通常指事务高峰期，为保证核心业务正常运行，需要停掉一些不太重要的业务，或者当某些服务不可用时，执行备用逻辑从故障服务中快速失败或返回，以保障主体业务不受影响，
hystrix降级主要目的是容错，保证当前服务不受依赖服务的影响，从而提高服务健壮性。什么情况下会进入降级?断路器打开、资源池/信号量不足、执行以来服务调用超时、执行依赖服务异常
降级回退方式? 1）Fail Fast快速失败，快速失败是最普通的，未重写降级逻辑，任何类型的故障都将抛出异常；2）Fail Silence 在降级方法中返回null或者空数据结构；3）FallBack static
降级方法中返回静态默认值。4）FallBack stubbed 当命令返回一个包含多个字段的复合对象适合以stubbed方式回退 5）FallBack Via NetWork 有时依赖的服务调用失败可以从缓存
中取，由于又会发起远程调用所以建议重新封装Command，适用不同的ThreadPoolKey，与主线程隔离。6）primary+Secondary with FallBack 有时系统具有两种行为 主要和次要，二者涉及
不同网络调用和业务逻辑，所以需要将主次逻辑封装在不同command，使用线程池进行隔离，为实现主从逻辑切换，可将主次command封装在HystrixCommand的run方法中，并结合配置中心设置
的开关切换主从逻辑，由于主从逻辑都是经过线程隔离的HystrixCommand，因此外观HystrixCommand可以使用信号量隔离。

  Hystrix调用过程，对于一次依赖调用，会被封装在HystrixCommand对象中，调用的执行有两种，execute()同步执行以及queue()异步执行，执行前判断断路器开关是否打开
若打开则执行getFallBack()降级逻辑，如果断路器关闭则判断资源池或者信号量是否足够，不足则执行getFallBack()，否则执行run()，run方法超时、失败都会执行getFallBack()
并报告Metrics(此中数据包括执行成功、失败、超时等情况的数据)，Hystrix会计算一个断路器的健康值，即失败率，当失败率超过阈值则触发打开断路器。
  getFallBack()方法逻辑：如果没有实现fallBack()方法则抛出异常，此外fallback降级亦需要资源，在fallback时需要获取一个针对fallback信号量，获取成功才能fallBack，
获取信号量失败会抛异常，只有成功获取信号量才能执行fallback方法。

</pre>

## **RPC**
<pre>
RPC的目的是解决远程调用的问题，
</pre>





## **熔断使用**
<pre>
</pre>

<h2>设计模式</h2>

## **工厂方法**
<pre>
  工厂方法模式属于类创建模式又称多态工厂模式，工厂方法的意义在于定义一个创建产品对象的工厂接口，将实际上创建工作推迟到子类当中，核心工厂类不再负责产品的创建，
仅负责申明具体工厂子类需要实现的接口。
  优点：每添加一个具体对象只需添加一个对应具体工厂对象，原有工厂对象无需修改。
</pre>


## **抽象工厂**
<pre>
  工厂方法模式中每个工厂只考虑创建一类具体对象，这会导致系统中工厂类过多，增加系统开销。思考将一些相关的具体类组成一个【具体类族】由同一个工厂统一创建。

</pre>
````java
//定义抽象产品接口
public interface IProd{
  void open();
  void shutDown();
}
public class MiPhone implements IProd{
  @Override
  public void open(){}
  @Override
  public void shutDown(){}
}
public class HuaWeiPhone implements IProd{
  @Override
  public void open(){}
  @Override
  public void shutDown(){}
}
abstract class PordFactory{
  abstract IProd prod();
}
public class MIFactory extends PordFactory{
  @Override
  public IPhoneProd prod(){
    return new MiPhone();
  }
}
public class HuaWeiFactory extends PordFactory{
  @Override
  public IProd prod(){
    return new HuaWeiPhone();
  }
}
//如果想要增加产品那要怎么办 比如加个Router
public class MiRouter implements IProd{
  @Override
  public void open(){}
  @Override
  public void shutDown(){}
}
//然后在ProdFactory工厂类中加上 prodRouter方法，这种抽象工厂不好的地方就是一旦新加工厂方法需要所有工厂都实现对应方法
````
## **装饰器模式**
<pre>
  以饼干为例，定义一个抽象类Cookie或者接口Cookie，所有类型的饼干都需继承自此类，Cookie类包含两个方法：getDescription，getCost，CookieOne继承Cookie并实现两抽象方法，CookieTwo
也类似于此，之后每当我们新加一种类型Cookie时都需要新加一个类，但这样类会越来越多，我们来使用装饰模式进行改动。思考 以饼干为主体使用不同原料制作，花费也不一样。
  定义抽象类或者接口Cookie；定义ConcreateCookie类具体构件或者说是基础构件，作为抽象类实现的基础，可以单独使用也可以对其进行装饰；定义Decorator装饰角色，一般是抽象
类，继承或者实现Cookie，Decorator中属性一般都有个变量指向Cookie；定义ConcreateDecorator具体装饰角色，用来将基础构件装饰成新的东西如将普通Cookie装饰为芝麻Cookie，
</pre>
````java
//基础抽象
public abstract class Cookie{
  public abstract void description();
  public abstract void cost();
}
//基础实现
public class ConcreateCookie extends Cookie{
  @Override
  public void description(){}
  @Override
  public void cost(){}
}
//抽象装饰类
public abstract class Decorator extends Cookie{
  private Cookie cookie =null;
  public Decorator(Cookie cookie){
    this.cookie=cookie;
  }
  @Override
  public void description(){cookie.description();}
  @Override
  public void cost(){cookie.cost();}
}
//具体装饰类
public class ConcreateDecotrator extends Decorator{
  public ConcreateDecotrator(Cookie cookie){super(cookie);}
  @Override
  public void description(){
    myDescription();
    super.description();
  }
  @Override
  public void cost(){
    myCost();
    super.cost();
  }
  private void myDescription(){
    //写逻辑
  }
  private void myCost(){
    //写逻辑
  }
}
//使用样例
public class Test{
  public static void main(String[] args){
    Cookie cookie = new ConcreateCookie();
    cookie=new ConcreateDecotrator(cookie);
    cookie.description();
    cookie.cost();
  }
}
````
## **装饰模式与代理区别**
<pre>
  让别人帮助做不关心的事叫代理，为了让自己的能力增强使得增强后的自己能使用更多的方法扩展在自己基础上的功能叫装饰模式，对装饰模式而言装饰者与被装饰者都实现相同接口或者
继承相同抽象类。对代理模式来说，代理类和真实处理类都实现相同接口二者边界较模糊。
  1.装饰模式强调自身增强，被装饰的自身能在被增强的类上使用增强后的功能，自身还是自身只是能力得到提升而已；代理强调让别人帮助做一些与自身业务没有太大关系的事情，日志或者
缓存，因为被代理的对象通常难以直接获得或者是内部不想暴露出来。
  2.装饰模式以对客户端透明的方式增强扩展对象的功能，是替代继承方案的；代理模式则是给一个对象提供一个代理对象由代理对象控制原有对象的引用。
  3.装饰模式是为装饰对象增强功能，代理模式是对代理对象进行控制，但不对对象本身进行增强。
</pre>

## **单例模式**
<pre>
  单例模式，类提供一种访问其唯一对象的方式，可以直接访问无需实例化该类的对象。有懒汉式、饿汉式、双检锁、静态内部类、枚举。
</pre>

````java
//懒汉式 在获取的时候判断static类型的实例是否存在，不存在则创建 存在则返回 方法如需要线程安全的话可加上 synchronized关键字
public class SingleTon{
  private static SingleTon instance;
  private SingleTon(){}  //构造方法私有
  public static SingleTon getInstance(){
    if(null==instance){
      instance = new SingleTon();
    }
    return instance;
  }
} 
//饿汉式 类初始化时创建实例 不存在线程安全的问题 但是如果不使用的话 instance占用的空间就属于浪费了
public class SingleTon{
  private static SingleTon instance = new SingleTon();
  private SingleTon(){}
  public static getInstance(){return instance;}
}
//双检锁 对懒汉模式进行改良
public class SingleTon{
  private volatile static SingleTon instance;
  private SingleTon(){}
  private static SingleTon getInstance(){
    if(instance==null){
        synchronized (SingleTon.class){
            if(null==instance){
                instance = new SingleTon();
            }
        }
    }
    return instance;
  }
}
//静态内部类 静态内部类方式效果类似双检锁，但实现更简单，但这种方法只适用静态域的情况
public class SingleTon{
  private static class SingleTonHolder{
    private static final SingleTon instance = new SingleTon();
  }
  private SingleTon(){}
  public static SingleTon getInstance(){
    return SingleTonHolder.instance;
  }
}
//枚举 此种方式实现单例比较少见，但简单清晰，且枚举支持序列化，绝对防止多次实例化
public enum SingleTon{
  INSTANCE;
  public void aMethod(){}
}

//ps：静态内部类可能存在反射攻击或者反序列化攻击
public class Test{
  public static void main(String[]args){
    SingleTon singleTon=SingleTon.getInstance();
    Constructor<SingleTon> constructor=SingleTon.class.getDeclaredConstructor();
    constructor.setAccessible(true);
    SingleTon aSingleTon=constructor.newInstance();
    System.out.println(singleTon==aSingleTon); //结果是false
  }
//反序列化需要SingleTon实现Serializable接口 通过反序列化工具获取新的instance
}

````

## **常见排序算法**
````java
public class Sort{
//冒泡排序
  public void bubbleSort(int[]arr,int len){ //冒泡排序思路：从数组第一个元素到最后一个元素，相邻两两比较，交换位置，直到整个数组有序 O(n^2)
    //这里以排序从小到大为例
    for(int i=0;i<len-1;i++){
        for(j=i+1;j<len;j++){
            if(arr[i]>arr[j]){
                int temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
        }
    }
  }
//选择排序
  public void selectSort(int[]arr,int len){//选择排序思路：每一趟n-i+1（i=1..n-1）个记录中选择最小或者最大的记录放到这一趟最前，O(n^2)
    for(int i =0 ;i<len-1;i++){
        for(int j = i+1;j<len;j++){
            if(arr[i]>arr[j]){
                int temp = arr[i];
                arr[i] =arr[j];
                arr[j]=temp;  
            }
        }
    }
  }
//插入排序
  public void insertSort(int[]arr,int len){//插入排序思路：将无序序列插入到有序序列中，如 4，8，2，0 分有序序列 4 无序序列 8，2，0；将8插入 有序变为 4，8
//无序变为 2，0；第二趟 将 2 插入 4，8 有序变为 2，4，8 ，再将0 插入
    for(int i=1;i<len;i++){//arr[0] 视为有序序列 所以从1开始
        for(j=i-1;j>0;j--){// arr[i]之前的数据都是有序的 所以从i-1开始
            if(arr[i]>arr[j]){break;}//这样最好 什么都不用改 直接i+1
            int temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
            while(j>0&&arr[j]>arr[j-1]){
                int tmp=arr[j];
                arr[j]=arr[j-1];
                arr[j-1]=tmp;
            }
        }
    }
  }
//希尔排序
  public void shellSort(int[]arr,int len){//希尔排序思想：在插入排序上改进，将待排序序列分割成多个子序列分别进行插入排序，等整个序列基本有序后，再整体插入排序
     for(int gap = len/2; i >0 ; gap/=2) {
         for(int i = gap; i <arr.length ; i++) {
            int k=i;
            while((k-gap>=0)&&arr[k]<arr[k-gap]){
                int temp =arr[k];
                arr[k]=arr[k-gap];
                arr[k-gap]=temp;
                k-=gap;
            }
         }
     }
  }
//快速排序
  public void quickSort(int[]arr,int len){//快速排序思想：设置一个key值，通过一趟排序将记录分两部分，一部分比key大，一部分比key小；设置高低两指针分别指向待排
//序列头尾，记录基准值value(通常是第一个)，然后从尾指针位置向前搜索直到比value小，记录并交换，然后移动头指针找比value大的，记录并交换，重复直到头尾指针相等。
      quickSort(arr,0,len-1);
  }
  public int getProvit(int[]arr,int left,int right){
    int key=arr[left];
    while(left<right){
        while(left<right&&arr[right]>key){
            right++;
        }
        arr[left]=arr[right];
        while (left<right&&arr[left]<key){
            left--;
        }
        arr[right]=arr[left];
    }
    arr[left]=key;
    return left;
  }
  public void quickSort(int[]arr,int left,int right){
    if(left<right){
        int index=getProvit(arr,left,right);
        quickSort(arr,left,index-1);
        quickSort(arr,index+1,right);
    }
  }
//归并排序
  public void mergeSort(int[]arr,int len){//归并是将两个或两个以上有序序列合成一个新的有序表，假设初始序列有n个记录，则可以视为n个有序序列，进行两两归并，又称二路归并
  //归并排序分为分和治
  
  }
  private void mergeSort_devide(int[]arr,int left,int right){
    if(left<right){
      int mid = (right-left)>>1+left;
      mergeSort_devide(arr,left,mid-1);
      mergeSort_devide(arr,mid+1,right);
      mergeSort_merge(arr,left,mid,right);
    }
  }
  private void mergeSort_merge(int[]arr,int left,int mid,int right){
    int l=left,m=mid;
    int i = right-left+1;//临时数组长度
    int[]tmp=new int[i];
    while(i<right&&l<=mid&&r>mid){
      tmp[i++]=arr[l]<arr[m+1]?arr[l++]:arr[++m];
    }
    while(l<=mid){
      tmp[i++]=arr[l++];
    }
    while (m<right){
      tmp[i++]=arr[++m];
    }
    int k=left;
    for(int i = 0; i < tmp.length; i++) {
      arr[k+i]=tmp[i];
    }
  }
}
````

## **字符型常量和字符串常量区别**
<pre>
  1.形式，字符常量是单引号引起的单个字符，字符串是双引号引起的若干个字符
  2.含义，字符常量相当于整型值(ASCII)，可以参与表达式运算，字符串常量则是地址值(该字符串在内存中的地址)
  3.占内存大小，字符常量只占两字节，字符串常量占若干字节(char在Java中占两字节)
  ps：字符封装类Character 有一个成员变量Character.SIZE 值为16 单位是bits，1byte=8bits；16/8=2 字节
</pre>

## **Java泛型、类型擦除**
<pre>
Java泛型是jdk5中引入的新特性，泛型提供编译时类型安全检测，该机制允许开发人员在编译时检测到非法类型，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，
Java泛型是伪泛型，因为Java在编译期间会将所有的泛型信息擦除。
  泛型通常有三种用法，泛型类、泛型接口、泛型方法
</pre>


````java
  //伪泛型
public class Test{
  public void test(){
    List<Integer>list=new ArrayList<>();
    list.add(2);
    list.add("2");//实际上这里会报错，编译不通过  可以通过反射添加
    Class<? extends List>clazz= list.getClass();
    Mehtod method=clazz.getDeclaredMethod("add",Object.class);
    method.invoke(list,"2str");
    System.out.println(list);
  }
}
//泛型类 这里不是一定要T 可以实 E、S、V 七七八八的
public class Generic<T>{
  private T t;
  public Generic(T t){
    this.t=t;
  }
  public T getKey(){return t;}
  public static void main(String[] args){
    //实例化泛型类
    Generic<Test> gt =new Generic<>(new Test());
  }
}
//泛型接口 
public interface Generator<T>{
  T method();
}
//实现泛型接口 指定类型
class GeneratorImpl implements Generator<Test>{
  @Override
  public Test method(){
    return new Test();
  }
}
class SMethod{
//泛型方法
  public static <S>void printArray(S[]arr){
    for(S s:arr){
      System.out.println(s);
      }
  }
  public static void main(String[] args){
    printArray(new Integer[]{2,1});
    printArray(new String[]{"aa","bb"});
  }
}
````
## **常用通配符T、E、K、V、?**
<pre>
-T type 表示一个具体Java类型
-K，V 分别代表Java键值中的Key，Value
-E 代表Element
-? 表示不确定的Java类型
</pre>

## **==和 equals 的区别**
<pre>
  对于基本数据类型而言，==比较的是值，对于引用数据类型而言 == 比较的是对象内存地址；因为Java只有值传递，所以对于==而言不管是比较基本数据类型还是引用数据类型，本质比较的都是
值，只是引用类型变量存的是对象地址。
  equals作用不能用于判断
</pre>




















